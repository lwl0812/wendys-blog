---
_title: 创建对象
description: JavaScript 高级教程
sidebar: auto
displayAllHeaders: true
tag: JavaScript
public: false
---

# 6.2 创建对象

Object 构造函数和对象字面量都可以用来创建单个对象，但是会产生大量重复代码。

## 6.2.1 工厂模式

```js
function createPerson(name, age, job) {
  let o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    console.log(this.name)
  }
  return o;
}

const person1 = createPerson('Mike', 28, 'xxx');
console.log(person1);
person1.sayName();
const person2 = createPerson('Mike', 24, 'aaa');
console.log(person2);
person2.sayName();
```

缺点：无法识别对象的类型。

## 6.2.2 构造函数模式

构造函数可以用来创建特定类型的对象。


```js
function Person(name, age , job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    console.log(this.name);
  }
}

const person1 = new Person('Mike', 28, 'teacher');
console.log(person1);
person1.sayName();
const person2 = new Person('Danie', 24, 'doctor');
console.log(person2);
person2.sayName();
```

与工厂模式的区别：

- 没有显示的创建对象
- 将属性和方法赋值给了this对象
- 没有return语句

要创建 Person 的新实例，必须使用 new 操作符。

经历四个步骤：

- 创建一个新对象
- 将作用域赋值给这个新对象--因此 this 指向了这个新对象
- 执行构造函数中的代码--给这个对象添加新属性
- 返回这个对象

person1 和 person2 都保存着 Person 的不同实例，都有一个 constructor （构造函数）属性，指向 Person。

```js
function Person(name, age , job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    console.log(this.name);
  }
}

const person1 = new Person('Mike', 28, 'teacher');
console.log(person1);
/**
  Person {name: "Mike", age: 28, job: "teacher", sayName: ƒ}
    age: 28
    job: "teacher"
    name: "Mike"
    sayName: ƒ ()
    __proto__:
      constructor: ƒ Person(name, age, job)  <-- constructor 属性
      __proto__: Object
*/
console.log(person1.constructor); // 打印 person1 的构造函数
/**
  ƒ Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function() {
      console.log(this.name);
    };
  }
 */
console.log(Person.constructor); // 打印 Person 的构造函数
// ƒ Function() { [native code] }
```

对象的 constructor 属性用来标识对象类型。

如果要检测对象类型，用 instanceof 操作符。

```js
console.log(person1 instanceof Person); // true
console.log(person1 instanceof Object); // true 所有对象均继承自 Object
console.log(Person instanceof Object); // true 所有对象均继承自 Object
```

缺点：每个实例的方法都要重新创建一遍。实例上的同名方法不相等。

```js
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    console.log(this.name);
  };
}

const person1 = new Person('Mike', 28, 'teacher');
const person2 = new Person('Danie', 24, 'doctor');
console.log(person1.sayName === person2.sayName); // false <-- 不同实例上的同名方法不相等
```

创建两个完成相同任务的 Function 实例没有必要，可以像下面这样实现：

```js
function sayName() {
  console.log(this.name);
}

function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = sayName;
}

const person1 = new Person('Mike', 28, 'teacher');
const person2 = new Person('Danie', 24, 'doctor');
console.log(person1.sayName === person2.sayName); // true
```

缺点：在全局定义很多函数，没有封装性。



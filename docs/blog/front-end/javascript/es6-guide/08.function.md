---
_title: 函数的扩展
description: ES6
sidebar: auto
displayAllHeaders: true
tag: JavaScript
public: false
---

# 函数的扩展

## 基本用法

ES6 之前不能为函数的参数指定默认值：

```js
const hello = (name) => {
  name = name || 'World';
  return `Hello ${name}`;
}

log(hello()); // 'Hello World'
log(hello('China')); // 'Hello China'
// 缺点：如果参数赋值了，但是对应的布尔值是 false，则赋值不起作用
log(hello('')); // 'Hello World'
log(hello(false)); // 'Hello World'
```

为了避免上面这个问题，通常需要判断参数是否被赋值。

```js
const hello = (name) => {
  if (typeof name === 'undefined') {
    name = 'World';
  }
  return `Hello ${name}`;
}

log(hello()); // 'Hello World'
log(hello('China')); // 'Hello China'
log(hello('')); // 'Hello '
log(hello(false)); // 'Hello false'
```

ES6 的语法：

```js
const hello = (name = 'World') => {
  return `Hello ${name}`;
};

log(hello()); // 'Hello World'
log(hello('China')); // 'Hello China'
log(hello('')); // 'Hello '
log(hello(false)); // 'Hello false'
```

函数参数是默认声明的，所以不能再用 const 或 let 声明。

使用参数默认值时，不能有同名参数。

```js
const hello = (name = 'World', name) => {
  return `Hello ${name}`;
};
// Uncaught SyntaxError: Duplicate parameter name not allowed in this context
```

参数默认值不是传值的，而是每次都重新计算默认值表达式的值。

```js
let x = 10;

const calculate = (a = x + 1) => {
  return a;
};

log(calculate(x)); // 10
x = 11;
log(calculate(x)); // 11
```

## 与解构赋值默认值结合使用

```js
const foo = ({x, y = 1}) => {
  console.log(x, y);
};

foo({}); // undefined 1
foo({x: 1, y: 2}); // 1 2
foo({x: 1}); // 1 1
foo(); // Uncaught TypeError: Cannot destructure property `x` of 'undefined' or 'null'.
```

提供函数参数的默认值，就不会报错。

```js
const foo = ({x, y = 1} = {}) => {
  console.log(x, y);
};
foo(); // undefined 1
```

两种写法的差别：

```js
const foo1 = ({x = 1, y = 2} = {}) => {
  console.log(x, y);
};

const foo2 = ({x, y} = {x: 1, y: 2}) => {
  console.log(x, y);
};

foo1(); // 1 2
foo2(); // 1 2

foo1({x: 3, y: 4}); // 3 4
foo2({x: 3, y: 4}); // 3 4

foo1({x: 3}); // 3 2
foo2({x: 3}); // 3 undefined

foo1({}); // 1 2
foo2({}); // undefined undefined
```

## 参数默认值的位置

有默认值的参数不是尾参数，不能只省略该参数，不省略后面的参数。

```js
const foo = (x = 1, y) => {
  console.log(x, y);
};

foo(); // 1 undefined
foo(2); // 2 undefined
foo(undefined, 1); // 1 1
foo(, 2); // Uncaught SyntaxError: Unexpected token ,
```

传入 undefined 可以触发参数的默认值，null 不会。

```js
foo(null, 1); // null 1
```

## 函数的 length 属性

返回没有指定默认值的参数的个数。

```js
const foo = (x, y) => {};
log(foo.length); // 2
```

```js
const foo = (x, y = 1) => {};
log(foo.length); // 1
```

length 的含义是该函数预期传入的参数个数，指定默认值后，预期传入的参数个数就不包括这个参数了。

rest 参数也不会计入参数个数。

```js
const foo = (...rest) => {};
log(foo.length); // 0
```

如果设置的默认值参数不是尾参数，那么其后面的参数也不会计入参数个数。

```js
const foo = (x = 1, y) => {};
log(foo.length); // 0
```

## 作用域

设置了参数默认值，函数只声明初始化时，参数会形成一个单独的作用域，等到初始化结束后，这个作用域会消失。在不设置默认值时，不出现这个作用域。

```js
const x = 1;
const foo = (x, y = x) => { // <-- 在单独的作用域中，y 指向的是这个作用域中的 x，即 2
  console.log(y);
};
foo(2); // 2
```

```js
const x = 1;
const foo = (y = x) => {
  console.log(y);
};
foo(); // 1 如果未传入 x，会指向全局的变量
```

全局变量 x 不存在，会报错。

```js
const foo = (y = x) => {
  console.log(y);
};
foo(); // Uncaught ReferenceError: x is not defined
```

```js
const x = 1;
const foo = (x = x) => {
  console.log(x);
};
foo(2); // 2
```

```js
const x = 1;
const foo = (x = x) => {
  console.log(x);
};
foo(); // 暂时性死区 demo.js:143 Uncaught ReferenceError: Cannot access 'x' before initialization
```

## 应用

利用参数默认值，可以指定某个参数不可省略，如果省略就抛出错误。

```js
const throwIfMissing = () => {
  throw new Error('Missing parameter.');
};

const foo = (name = throwIfMissing()) => {
  return name;
};

foo(); // Uncaught Error: Missing parameter.
```

## rest 参数

用于获取函数的剩余参数。

```js
const sum = (...values) => {
  return values.reduce((accumulator, current) => {
    return accumulator + current;
  }, 0);
};

console.log(sum(1, 2, 3)); // 6
```

rest 参数代替 arguments 变量：

```js
const sum = (...values) => {
  return values.sort();
};
```

rest 参数后不能再有其他参数，否则会报错。



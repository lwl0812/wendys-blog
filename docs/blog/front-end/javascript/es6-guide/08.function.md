---
_title: 函数的扩展
description: ES6
sidebar: auto
displayAllHeaders: true
tag: JavaScript
public: false
---

# 函数的扩展

## 基本用法

ES6 之前不能为函数的参数指定默认值：

```js
const hello = (name) => {
  name = name || 'World';
  return `Hello ${name}`;
}

log(hello()); // 'Hello World'
log(hello('China')); // 'Hello China'
// 缺点：如果参数赋值了，但是对应的布尔值是 false，则赋值不起作用
log(hello('')); // 'Hello World'
log(hello(false)); // 'Hello World'
```

为了避免上面这个问题，通常需要判断参数是否被赋值。

```js
const hello = (name) => {
  if (typeof name === 'undefined') {
    name = 'World';
  }
  return `Hello ${name}`;
}

log(hello()); // 'Hello World'
log(hello('China')); // 'Hello China'
log(hello('')); // 'Hello '
log(hello(false)); // 'Hello false'
```

ES6 的语法：

```js
const hello = (name = 'World') => {
  return `Hello ${name}`;
};

log(hello()); // 'Hello World'
log(hello('China')); // 'Hello China'
log(hello('')); // 'Hello '
log(hello(false)); // 'Hello false'
```

函数参数是默认声明的，所以不能再用 const 或 let 声明。

使用参数默认值时，不能有同名参数。

```js
const hello = (name = 'World', name) => {
  return `Hello ${name}`;
};
// Uncaught SyntaxError: Duplicate parameter name not allowed in this context
```

参数默认值不是传值的，而是每次都重新计算默认值表达式的值。

```js
let x = 10;

const calculate = (a = x + 1) => {
  return a;
};

log(calculate(x)); // 10
x = 11;
log(calculate(x)); // 11
```

## 与解构赋值默认值结合使用

```js
const foo = ({x, y = 1}) => {
  console.log(x, y);
};

foo({}); // undefined 1
foo({x: 1, y: 2}); // 1 2
foo({x: 1}); // 1 1
foo(); // Uncaught TypeError: Cannot destructure property `x` of 'undefined' or 'null'.
```

提供函数参数的默认值，就不会报错。

```js
const foo = ({x, y = 1} = {}) => {
  console.log(x, y);
};
foo(); // undefined 1
```

两种写法的差别：

```js
const foo1 = ({x = 1, y = 2} = {}) => {
  console.log(x, y);
};

const foo2 = ({x, y} = {x: 1, y: 2}) => {
  console.log(x, y);
};

foo1(); // 1 2
foo2(); // 1 2

foo1({x: 3, y: 4}); // 3 4
foo2({x: 3, y: 4}); // 3 4

foo1({x: 3}); // 3 2
foo2({x: 3}); // 3 undefined

foo1({}); // 1 2
foo2({}); // undefined undefined
```